<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<!--
 - Copyright (C) 2000  Internet Software Consortium.
 -
 - Permission to use, copy, modify, and distribute this software for any
 - purpose with or without fee is hereby granted, provided that the above
 - copyright notice and this permission notice appear in all copies.
 -
 - THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 - DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 - INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 - FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 - NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 - WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-->

<!-- $Id: Bv9ARM.4.html,v 1.5.2.4 2000/08/22 19:29:09 gson Exp $ -->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML EXPERIMENTAL 970324//EN">
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="Bv9ARM.css">
<TITLE> Section 4.	Advanced Concepts</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">

<H1 CLASS="1Level">
<A NAME="pgfId=997350">
</A>
Section 4.	Advanced Concepts</H1>

<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=997351">
</A>
4.1	<A NAME="39835">
</A>
Dynamic Update</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=997352">
</A>
Dynamic update is the term used for the ability under certain specified conditions to add, modify or delete records or RRsets in the master zone files. Dynamic update is fully described in RFC 2136.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997353">
</A>
Dynamic update is enabled on a zone-by-zone basis, by including an <CODE CLASS="Program-Process">
allow-update</CODE>
 or <CODE CLASS="Program-Process">
update-policy</CODE>
 clause in the <CODE CLASS="Program-Process">
zone</CODE>
 statement.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1008560">
</A>
Updating of secure zones (zones using DNSSEC) is modelled after the <EM CLASS="Emphasis">
simple-secure-update</EM>
 proposal, a work in progress in the DNS Extensions working group of the IETF. (See<BR>
<EM CLASS="URL">
<A HREF="http://www.ietf.org/html.charters/dnsext-charter.html">http://www.ietf.org/html.charters/dnsext-charter.html</A></EM>
 for information about the DNS Extensions working group.) SIG and NXT records affected by updates are automatically regenerated by the server using an online zone key. Update authorization is based on transaction signatures and an explicit server policy.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1008576">
</A>
The zone files of dynamic zones must not be edited by hand. The zone file on disk at any given time may not contain the latest changes performed by dynamic update. The zone file is written to disk only periodically, and changes that have occurred since the zone file was last written to disk are stored only in the zone's journal (<EM CLASS="pathname">
.jnl</EM>
) file. BIND&nbsp;9 currently does not update the zone file when it exits as BIND 8 does, so editing the zone file manually is unsafe even when the server has been shut down. </P>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=997356">
</A>
4.2	<A NAME="19780">
</A>
Incremental Zone Transfers (IXFR)</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1008466">
</A>
The incremental zone transfer (IXFR) protocol is a way for slave servers to transfer only changed data, instead of having to transfer the entire zone. The IXFR protocol is documented in RFC 1995. See the list of proposed standards in <A HREF="Bv9ARM.9.html#17631" CLASS="XRef">Appendix C
</A>
.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1008471">
</A>
When acting as a master, BIND&nbsp;9 supports IXFR for those zones where the necessary change history information is available. These include master zones maintained by dynamic update and slave zones whose data was obtained by IXFR, but not manually maintained master zones nor slave zones obtained by performing a full zone transfer (AXFR).</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1008502">
</A>
When acting as a slave, BIND&nbsp;9 will attempt to use IXFR unless it is explicitly disabled. For more information about disabling IXFR, see the description of the <CODE CLASS="Program-Process">
request-ixfr</CODE>
 clause of the <CODE CLASS="Program-Process">
server</CODE>
 statement.</P>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=997360">
</A>
4.3	Split DNS</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=997361">
</A>
Setting up different views, or visibility, of DNS space to internal and external resolvers is usually referred to as a <EM CLASS="Emphasis">
Split DNS</EM>
 setup. There are several reasons an organization would want to set up its DNS this way.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997362">
</A>
One common reason for setting up a DNS system this way is to hide &quot;internal&quot; DNS information from &quot;external&quot; clients on the Internet. There is some debate as to whether or not this is actually useful. Internal DNS information leaks out in many ways (via email headers, for example) and most savvy &quot;attackers&quot; can find the information they need using other means.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997363">
</A>
Another common reason for setting up a Split DNS system is to allow internal networks that are behind filters or in RFC 1918 space (reserved IP space, as documented in RFC 1918) to resolve DNS on the Internet. Split DNS can also be used to allow mail from outside back in to the internal network.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997364">
</A>
Here is an example of a split DNS setup:</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997365">
</A>
Let's say a company named <EM CLASS="Emphasis">
Example, Inc.</EM>
 (example.com) has several corporate sites that have an internal network with reserved Internet Protocol (IP) space and an external demilitarized zone (DMZ), or &quot;outside&quot; section of a network, that is available to the public.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997366">
</A>
<EM CLASS="Emphasis">
Example, Inc.</EM>
 wants its internal clients to be able to resolve external hostnames and to exchange mail with people on the outside. The company also wants its internal resolvers to have access to certain internal-only zones that are not available at all outside of the internal network.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997367">
</A>
In order to accomplish this, the company will set up two sets of nameservers. One set will be on the inside network (in the reserved IP space) and the other set will be on bastion hosts, which are &quot;proxy&quot; hosts that can talk to both sides of its network, in the DMZ.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997368">
</A>
The internal servers will be configured to forward all queries, except queries for <EM CLASS="pathname">
site1.internal</EM>
, <EM CLASS="pathname">
site2.internal</EM>
, <EM CLASS="pathname">
site1.example.com</EM>
, and <EM CLASS="pathname">
site2.example.com</EM>
, to the servers in the DMZ. These internal servers will have complete sets of information for <EM CLASS="pathname">
site1.example.com</EM>
, <EM CLASS="pathname">
site2.example.com</EM>
,<EM CLASS="Emphasis">
 </EM>
<EM CLASS="pathname">
site1.internal</EM>
, and <EM CLASS="pathname">
site2.internal</EM>
.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997369">
</A>
To protect the<EM CLASS="pathname">
 site1.internal</EM>
 and
<EM CLASS="pathname">
site2.internal</EM>
 domains, the internal nameservers must be configured to disallow all queries to these domains from any external hosts, including the bastion hosts.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997370">
</A>
The external servers, which are on the bastion hosts, will be configured to serve the &quot;public&quot; version of the <EM CLASS="pathname">
site1</EM>
 and <EM CLASS="pathname">
site2.example.com</EM>
 zones. This could include things such as the host records for public servers (<EM CLASS="pathname">
www.example.com</EM>
 and <EM CLASS="pathname">
ftp.example.com</EM>
), and mail exchange (MX)  records (<EM CLASS="pathname">
a.mx.example.com</EM>
 and <EM CLASS="pathname">
b.mx.example.com</EM>
).</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997371">
</A>
In addition, the public <EM CLASS="pathname">
site1</EM>
 and <EM CLASS="pathname">
site2.example.com</EM>
 zones should have special MX records that contain wildcard ('*') records pointing to the bastion hosts. This is needed because external mail servers do not have any other way of looking up how to deliver mail to those internal hosts. With the wildcard records, the mail will be delivered to the bastion host, which can then forward it on to internal hosts.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997372">
</A>
Here's an example of a wildcard MX record:</P>
<PRE>
<CODE><STRONG>
*   IN MX 10 external1.example.com.
</STRONG></CODE></PRE>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997374">
</A>
Now that they accept mail on behalf of anything in the internal network, the bastion hosts will need to know how to deliver mail to internal hosts. In order for this to work properly, the resolvers on the bastion hosts will need to be configured to point to the internal nameservers for DNS resolution.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997375">
</A>
Queries for internal hostnames will be answered by the internal servers, and queries for external hostnames will be forwarded back out to the DNS servers on the bastion hosts.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997376">
</A>
In order for all this to work properly, internal clients will need to be configured to query <EM CLASS="Emphasis">
only</EM>
 the internal nameservers for DNS queries. This could also be enforced via selective filtering on the network.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997377">
</A>
If everything has been set properly, <EM CLASS="Emphasis">
Example, Inc.</EM>
's internal clients will now be able to:</P>
<UL>
<LI CLASS="2Level-bullet1">
<A NAME="pgfId=997378">
</A>
Look up any hostnames in the <EM CLASS="pathname">
site1</EM>
 and <EM CLASS="pathname">
site2.example.com</EM>
 zones.</LI>
<LI CLASS="2Level-bullet2">
<A NAME="pgfId=997379">
</A>
Look up any hostnames in the <EM CLASS="pathname">
site1.internal</EM>
 and <EM CLASS="pathname">
site2.internal</EM>
 domains.</LI>
<LI CLASS="2Level-bullet2">
<A NAME="pgfId=997380">
</A>
Look up any hostnames on the Internet.</LI>
<LI CLASS="2Level-bullet2">
<A NAME="pgfId=997381">
</A>
Exchange mail with internal AND external people.</LI>
</UL>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997382">
</A>
Hosts on the Internet will be able to:</P>
<UL>
<LI CLASS="2Level-bullet1">
<A NAME="pgfId=997383">
</A>
Look up any hostnames in the <EM CLASS="pathname">
site1</EM>
 and <EM CLASS="pathname">
site2.example.com </EM>
zones.</LI>
<LI CLASS="2Level-bullet2">
<A NAME="pgfId=997384">
</A>
Exchange mail with anyone in the <EM CLASS="pathname">
site1</EM>
 and <EM CLASS="pathname">
site2.example.com</EM>
 zones.</LI>
</UL>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997385">
</A>
Here is an example configuration for the setup we just described above. Note that this is only configuration information; for information on how to configure your zone files, see the <A HREF="Bv9ARM.3.html#30164" CLASS="XRef">Sample Configurations
</A>
.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997389">
</A>
Internal DNS server config:</P>


<PRE>
<CODE><STRONG>acl internals { 172.16.72.0/24; 192.168.1.0/24; };
acl externals { bastion-ips-go-here; };
options {
    ...
    ...
    forward only;
    forwarders { bastion-ips-go-here; };	// forward to external servers
    allow-transfer { none; };			// sample allow-transfer (no one)
    allow-query { internal; externals; };	// restrict query access
    allow-recursion { internals; };		// restrict recursion
    ...
    ...
};
</STRONG></CODE></PRE>
<PRE>
<CODE><STRONG>zone &quot;site1.example.com&quot; { 			// sample slave zone
  type master;
  file &quot;m/site1.example.com&quot;;
  forwarders { }; 				// do normal iterative
						// resolution (do not forward)
  allow-query { internals; externals; };
  allow-transfer { internals; };
  };
</STRONG></CODE></PRE>
<PRE>
<CODE><STRONG>zone &quot;site2.example.com&quot; {
  type slave;
  file &quot;s/site2.example.com&quot;;
  masters { 172.16.72.3; };
  forwarders { };
  allow-query { internals; externals; };
  allow-transfer { internals; };
};
</STRONG></CODE></PRE>
<PRE>
<CODE><STRONG>zone &quot;site1.internal&quot; {
  type master;
  file &quot;m/site1.internal&quot;;
  forwarders { };
  allow-query { internals; };
  allow-transfer { internals; }
};</STRONG></CODE>
</PRE>
<PRE>
<CODE><STRONG>zone &quot;site2.internal&quot; {
  type slave;
  file &quot;s/site2.internal&quot;;
  masters { 172.16.72.3; };
  forwarders { };
  allow-query { internals };
  allow-transfer { internals; }
};
</STRONG></CODE></PRE>
External (bastion host) DNS server config:

<PRE>
<CODE><STRONG>acl internals { 172.16.72.0/24; 192.168.1.0/24; };
acl externals { 
bastion-ips-go-here; };
options {
  ...
  ...
  allow-transfer { none; };			// sample allow-transfer (no one)
  allow-query { internals; externals; };	// restrict query access
  allow-recursion { internals; externals; };	// restrict recursion
  ...
  ...
};</STRONG></CODE>
</PRE>
<PRE>
<CODE><STRONG>zone &quot;site1.example.com&quot; { // sample slave zone
  type master;
  file &quot;m/site1.foo.com&quot;;
  allow-query { any; };
  allow-transfer { internals; externals; };
};</STRONG></CODE>
</PRE>
<PRE>
<CODE><STRONG>zone &quot;site2.example.com&quot; {
  type slave;
  file &quot;s/site2.foo.com&quot;;
  masters { another_bastion_host_maybe; };
  allow-query { any; };
  allow-transfer { internals; externals; }
};
</STRONG></CODE></PRE>

In the resolv.conf (or equivalent) on the bastion host(s):


<PRE>
<CODE><STRONG>search ...
nameserver 172.16.72.2
nameserver 172.16.72.3
nameserver 172.16.72.4</STRONG></CODE>
</PRE>

</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=997461">
</A>
4.4	<A NAME="42283">
</A>
TSIG</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=997462">
</A>
This is a short guide to setting up Transaction SIGnatures (TSIG) based transaction security in BIND. It describes changes to the configuration file as well as what changes are required for different features, including the process of creating transaction keys and using transaction signatures with BIND.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997463">
</A>
BIND primarily supports TSIG for server to server communication. This includes zone transfer, notify, and recursive query messages. Resolvers based on newer versions of BIND&nbsp;8 have limited support for TSIG.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=997464">
</A>
TSIG might be most useful for dynamic update. A primary server for a dynamic zone should use access control to control updates, but IP-based access control is insufficient. Key-based access control is far superior. See RFC 2845 in the <A HREF="Bv9ARM.9.html#17631" CLASS="XRef">Proposed Standards
</A> section of the Appendix. The <CODE CLASS="Program-Process">
nsupdate</CODE>
 program supports TSIG via the &quot;<CODE CLASS="Program-Process">
-k</CODE>
&quot; and &quot;<CODE CLASS="Program-Process">
-y</CODE>
&quot;command line options.</P>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997465">
</A>
4.4.1	Generate Shared Keys for Each Pair of Hosts</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997466">
</A>
A shared secret is generated to be shared between <EM CLASS="Emphasis">
host1</EM>
 and <EM CLASS="Emphasis">
host2</EM>
. An arbitrary key name is chosen: &quot;host1-host2.&quot;. The key name must be the same on both hosts.</P>
<DIV>

<H5 CLASS="4Level">
<A NAME="pgfId=997467">
</A>
4.4.1.1	Automatic Generation</H5>

<P CLASS="4LevelContinued">
<A NAME="pgfId=997468">
</A>
The following command will generate a 128 bit (16 byte) HMAC-MD5 key as described above. Longer keys are better, but shorter keys are easier to read. Note that the maximum key length is 512 bits; keys longer than that will be digested with MD5 to produce a 128 bit key.</P>
<PRE>
<CODE><STRONG>
dnssec-keygen -a hmac-md5 -b 128 -n HOST host1-host2.
</STRONG></CODE></PRE>
<P CLASS="4LevelContinued">
<A NAME="pgfId=997470">
</A>
The key is in the file <EM CLASS="pathname">
Khost1-host2.+157+00000.private</EM>
. Nothing directly uses this file, but the base-64 encoded string following &quot;<EM CLASS="grammar_literal">
Key</EM>
:&quot; can be extracted from the file and used as a shared secret:</P>
<PRE>
<CODE><STRONG>
Key: La/E5CjG9O+os1jq0a2jdA==
</STRONG></CODE></PRE>
<P CLASS="4LevelContinued">
<A NAME="pgfId=997472">
</A>
The string &quot;<KBD CLASS="literal-user-input">
La/E5CjG9O+os1jq0a2jdA==</KBD>
&quot; can be used as the shared secret.</P>
</DIV>
<DIV>

<H5 CLASS="4Level">
<A NAME="pgfId=997473">
</A>
4.4.1.2	Manual Generation</H5>

<P CLASS="4LevelContinued">
<A NAME="pgfId=997474">
</A>
The shared secret is simply a random sequence of bits, encoded in base-64. Most ASCII strings are valid base-64 strings (assuming the length is a multiple of 4 and only valid characters are used), so the shared secret can be manually generated.</P>
<P CLASS="4LevelContinued">
<A NAME="pgfId=997475">
</A>
Also, a known string can be run through <CODE CLASS="Program-Process">
mmencode</CODE>
 or a similar program to generate base-64 encoded data.</P>
</DIV>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997476">
</A>
4.4.2	Copying the Shared Secret to Both Machines</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997477">
</A>
This is beyond the scope of DNS. A secure transport mechanism should be used. This could be secure FTP, ssh, telephone, etc.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997478">
</A>
4.4.3	Informing the Servers of the Key's Existence</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997479">
</A>
Imagine <EM CLASS="Emphasis">
host1</EM>
 and <EM CLASS="Emphasis">
host 2</EM>
 are both servers. The following is added to each server's <EM CLASS="pathname">
named.conf</EM>
 file:</P>

<PRE>
<CODE><STRONG>key host1-host2. {
  algorithm hmac-md5;
  secret &quot;La/E5CjG9O+os1jq0a2jdA==&quot;;
};</STRONG></CODE>
</PRE>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997484">
</A>
The algorithm, hmac-md5, is the only one supported by BIND. The secret is the one generated above. Since this is a secret, it is recommended that either <EM CLASS="pathname">
named.conf</EM>
 be non-world readable, or the key directive be added to a non-world readable file that is included by <EM CLASS="pathname">
named.conf</EM>
.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997485">
</A>
At this point, the key is recognized. This means that if the server receives a message signed by this key, it can verify the signature. If the signature succeeds, the response is signed by the same key.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997486">
</A>
4.4.4	Instructing the Server to Use the Key</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997487">
</A>
Since keys are shared between two hosts only, the server must be told when keys are to be used. The following is added to the <EM CLASS="pathname">
named.conf</EM>
 file for <EM CLASS="Emphasis">
host1</EM>
, if the IP address of <EM CLASS="Emphasis">
host2</EM>
 is 10.1.2.3:</P>
<PRE>
<CODE><STRONG>
server 10.1.2.3 {
  keys { host1-host2. ;};
};
</STRONG></CODE></PRE>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997491">
</A>
Multiple keys may be present, but only the first is used. This directive does not contain any secrets, so it may be in a world-readable file.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997492">
</A>
If <EM CLASS="Emphasis">
host1</EM>
 sends a message that is a response to that address, the message will be signed with the specified key. <EM CLASS="Emphasis">
host1</EM>
 will expect any responses to signed messages to be signed with the same key.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997493">
</A>
A similar statement must be present in <EM CLASS="Emphasis">
host2</EM>
's configuration file (with <EM CLASS="Emphasis">
host1</EM>
's address) for <EM CLASS="Emphasis">
host2</EM>
 to sign non-response messages to <EM CLASS="Emphasis">
host1</EM>
.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997494">
</A>
4.4.5	TSIG Key Based Access Control</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997495">
</A>
BIND allows IP addresses and ranges to be specified in ACL definitions and<BR>
<CODE CLASS="Program-Process">
allow-{ query | transfer | update } </CODE>
directives. This has been extended to allow TSIG keys also. The above key would be denoted <CODE CLASS="Program-Process">
key host1-host2.</CODE>
</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997496">
</A>
An example of an allow-update directive would be:</P>
<PRE>
<CODE><STRONG>
allow-update { key host1-host2. ;};
</STRONG></CODE></PRE>
<P CLASS="3LevelContinued">
<A NAME="pgfId=1060265">
</A>
This allows dynamic updates to succeed only if the request was signed by a key named &quot;<CODE CLASS="Program-Process">
host1-host2.</CODE>
&quot;.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=1060266">
</A>
The more powerful <CODE CLASS="Program-Process">
update-policy</CODE>
 statement is described <A HREF="Bv9ARM.6.html#13905" CLASS="XRef">Dynamic Update Policies</A>
.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1060267">
</A>
4.4.6	Errors</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=997500">
</A>
The processing of TSIG signed messages can result in several errors. If a signed message is sent to a non-TSIG aware server, a FORMERR will be returned, since the server will not understand the record. This is a result of misconfiguration, since the server must be explicitly configured to send a TSIG signed message to a specific server.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=997501">
</A>
If a TSIG aware server receives a message signed by an unknown key, the response will be unsigned with the TSIG extended error code set to BADKEY. If a TSIG aware server receives a message with a signature that does not validate, the response will be unsigned with the TSIG extended error code set to BADSIG. If a TSIG aware server receives a message with a time outside of the allowed range, the response will be signed with the TSIG extended error code set to BADTIME, and the time values will be adjusted so that the response can be successfully verified. In any of these cases, the message's rcode is set to NOTAUTH.</P>
</DIV>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=997505">
</A>
4.5	TKEY</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1021941">
</A>
<CODE CLASS="Program-Process">
TKEY</CODE>
 is a mechanism for automatically generating a shared secret between two hosts.  There are several &quot;modes&quot; of <CODE CLASS="Program-Process">
TKEY</CODE>
 that specify how the key is generated or assigned.  BIND implements only one of these modes, the Diffie-Hellman key exchange.  Both hosts are required to have a Diffie-Hellman KEY record (although this record is not required to be present in a zone).  The <CODE CLASS="Program-Process">
TKEY</CODE>
 process must use signed messages, signed either by TSIG or SIG(0).  The result of <CODE CLASS="Program-Process">
TKEY</CODE>
 is a shared secret that can be used to sign messages with TSIG.  <CODE CLASS="Program-Process">
TKEY</CODE>
 can also be used to delete shared secrets that it had previously generated.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1021952">
</A>
The <CODE CLASS="Program-Process">
TKEY</CODE>
 process is initiated by a client or server by sending a signed <CODE CLASS="Program-Process">
TKEY</CODE>
 query (including any appropriate KEYs) to a TKEY-aware server.  The server response, if it indicates success, will contain a <CODE CLASS="Program-Process">
TKEY</CODE>
 record and any appropriate keys.  After this exchange, both participants have enough information to determine the shared secret; the exact process depends on the <CODE CLASS="Program-Process">
TKEY</CODE>
 mode.  When using the Diffie-Hellman <CODE CLASS="Program-Process">
TKEY</CODE>
 mode, Diffie-Hellman keys are exchanged, and the shared secret is derived by both participants.</P>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=1051848">
</A>
4.6	SIG(0)</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1051854">
</A>
BIND&nbsp;9 partially supports DNSSEC SIG(0) transaction signatures as specified in RFC 2535.  SIG(0) uses public/private keys to authenticate messages.  Access control is performed in the same manner as TSIG keys; privileges can be granted or denied based on the key name.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1051850">
</A>
When a SIG(0) signed message is received, it will only be verified if the key is known and trusted by the server; the server will not attempt to locate and/or validate the key.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1051851">
</A>
BIND&nbsp;9 does not ship with any tools that generate SIG(0) signed messages.</P>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=1051846">
</A>
4.7	<A NAME="32571">
</A>
DNSSEC</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039857">
</A>
Cryptographic authentication of DNS information is possible through the DNS Security (<EM CLASS="Emphasis">
DNSSEC</EM>
) extensions, defined in RFC 2535. This section describes the creation and use of  DNSSEC signed zones.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039810">
</A>
In order to set up a DNSSEC secure zone, there are a series of steps which must be followed.  BIND&nbsp;9 ships with several tools that are used in this process, which are explained in more detail below.  In all cases, the &quot;<CODE CLASS="Program-Process">
-h</CODE>
&quot; option prints a full list of parameters.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039811">
</A>
There must also be communication with the administrators of the parent and/or child zone to transmit keys and signatures.  A zone's security status must be indicated by the parent zone for a DNSSEC capable resolver to trust its data.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039812">
</A>
For other servers to trust data in this zone, they must either be statically configured with this zone's zone key or the zone key of another zone above this one in the DNS tree.</P>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1039813">
</A>
4.7.1	Generating Keys</H4>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039814">
</A>
The <CODE CLASS="Program-Process">
dnssec-keygen</CODE>
 program is used to generate keys.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039815">
</A>
A secure zone must contain one or more zone keys.  The zone keys will sign all other records in the zone, as well as the zone keys of any secure delegated zones.  Zone keys must have the same name as the zone, a name type of <CODE CLASS="Program-Process">
ZONE</CODE>
, and must be usable for authentication.  It is recommended that zone keys be mandatory to implement a cryptographic algorithm; currently the only key mandatory to implement an algorithm is DSA.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039816">
</A>
The following command will generate a 768 bit DSA key for the <EM CLASS="pathname">
child.example</EM>
 zone:</P>

<PRE>
<CODE><STRONG>dnssec-keygen -a DSA -b 768 -n ZONE child.example.
</STRONG></CODE></PRE>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039818">
</A>
Two output files will be produced: <EM CLASS="pathname">
Kchild.example.+003+12345.key</EM>
 and <EM CLASS="pathname">
Kchild.example.+003+12345.private</EM>
 (where 12345 is an example of a key tag).  The key file names contain the key name (<EM CLASS="pathname">
child.example.</EM>
), algorithm (3 is DSA, 1 is RSA, etc.), and the key tag (12345 in this case).  The private key (in the <EM CLASS="pathname">
.private</EM>
 file) is used to generate signatures, and the public key (in the <EM CLASS="pathname">
.key</EM>
 file) is used for signature verification.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039819">
</A>
To generate another key with the same properties (but with a different key tag), repeat the above command.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039820">
</A>
The public keys should be inserted into the zone file with <CODE CLASS="Program-Process">
$INCLUDE</CODE>
 statements, including the <EM CLASS="pathname">
.key </EM>
files.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1039821">
</A>
4.7.2	Creating a Keyset</H4>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039822">
</A>
The <CODE CLASS="Program-Process">
dnssec-makekeyset</CODE>
 program is used to create a key set from one or more keys.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039823">
</A>
Once the zone keys have been generated, a key set must be built for transmission to the administrator of the parent zone, so that the parent zone can sign the keys with its own zone key and correctly indicate the security status of this zone.  When building a key set, the list of keys to be included and the TTL of the set must be specified, and the desired signature validity period of the parent's signature may also be specified.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039824">
</A>
The list of keys to be inserted into the key set may also included non-zone keys present at the apex.  <CODE CLASS="Program-Process">
dnssec-makekeyset</CODE>
 may also be used at non-apex names.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039825">
</A>
The following command generates a key set containing the above key and another key similarly generated, with a TTL of 3600 and a signature validity period of 10 days starting from now.</P>

<PRE>
<CODE><STRONG>dnssec-makekeyset -t 3600 -e +864000 Kchild.example.+003+12345 
Kchild.example.+003+23456</STRONG></CODE>
</PRE>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039827">
</A>
One output file is produced: <EM CLASS="pathname">
child.example.keyset</EM>
.  This file should be transmitted to the parent to be signed.  It includes the keys, as well as signatures over the key set generated by the zone keys themselves, which are used to prove ownership of the private keys and encode the desired validity period.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1039828">
</A>
4.7.3	Signing the Child's Keyset</H4>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039829">
</A>
The <CODE CLASS="Program-Process">
dnssec-signkey</CODE>
 program is used to sign one child's keyset.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039830">
</A>
If the <EM CLASS="pathname">
child.example</EM>
 zone has any delegations which are secure, for example, <EM CLASS="pathname">
grand.child.example</EM>
, the <EM CLASS="pathname">
child.example</EM>
 administrator should receive keyset files for each secure subzone.  These keys must be signed by this zone's zone keys.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039831">
</A>
The following command signs the child's key set with the zone keys:</P>

<PRE>
<CODE><STRONG>dnssec-signkey grand.child.example.keyset Kchild.example.+003+12345 
Kchild.example.+003+23456</STRONG></CODE>
</PRE>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039833">
</A>
One output file is produced: <EM CLASS="pathname">
grand.child.example.signedkey</EM>
. This file should be both transmitted back to the child and retained.  It includes all keys (the child's keys) from the keyset file and signatures generated by this zone's zone keys.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1040038">
</A>
4.7.4	Signing the Zone</H4>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1040039">
</A>
The <CODE CLASS="Program-Process">
dnssec-signzone</CODE>
 program is used to sign a zone.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1040040">
</A>
Any <EM CLASS="pathname">
signedkey</EM>
 files corresponding to secure subzones should be present, as well as a <EM CLASS="pathname">
signedkey</EM>
 file for this zone generated by the parent (if there is one). The zone signer will generate <CODE CLASS="Program-Process">
NXT</CODE>
 and <CODE CLASS="Program-Process">
SIG</CODE>
 records for the zone, as well as incorporate the zone key signature from the parent and indicate the security status at all delegation points.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039837">
</A>
The following command signs the zone, assuming it is in a file called <EM CLASS="pathname">
zone.child.example</EM>
.  By default, all zone keys which have an available private key are used to generate signatures.</P>

<PRE>
<CODE><STRONG>dnssec-signzone -o child.example zone.child.example
</STRONG></CODE></PRE>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039839">
</A>
One output file is produced: <EM CLASS="pathname">
zone.child.example.signed</EM>
. This file should be referenced by <EM CLASS="pathname">
named.conf</EM>
 as the input file for the zone.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1039840">
</A>
4.7.5	Configuring Servers</H4>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1039841">
</A>
Unlike in BIND&nbsp;8, data is not verified on load in BIND&nbsp;9, so zone keys for authoritative zones do not need to be specified in the configuration file.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1039842">
</A>
The public key for any security root must be present in the configuration file's<BR>
<CODE CLASS="Program-Process">
trusted-keys</CODE>
 statement, as described later in this document. </P>
</DIV>
</DIV>
<DIV>

<H3 CLASS="2Level">
<A NAME="pgfId=1051926">
</A>
4.8	IPv6 Support in BIND&nbsp;9</H3>

<P CLASS="2LevelContinued">
<A NAME="pgfId=1051937">
</A>
BIND&nbsp;9 fully supports all currently defined forms of IPv6 name to address and address to name lookups.  It will also use IPv6 addresses to make queries when running on an IPv6 capable system.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1051938">
</A>
For forward lookups, BIND&nbsp;9 supports both A6 and AAAA records.  The of AAAA records is deprecated, but it is still useful for hosts to have both AAAA and A6 records to maintain backward compatibility with installations where AAAA records are still used.  In fact, the stub resolvers currently shipped with most operating system support only AAAA lookups, because following A6 chains is much harder than doing A or AAAA lookups.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1051939">
</A>
For IPv6 reverse lookups, BIND&nbsp;9 supports the new &quot;bitstring&quot; format used in the <EM CLASS="URL">
ip6.arpa</EM>
 domain, as well as the older, deprecated &quot;nibble&quot; format used in the <EM CLASS="URL">
ip6.int</EM>
 domain.</P>
<P CLASS="2LevelContinued">
<A NAME="pgfId=1051940">
</A>
BIND&nbsp;9 includes a new lightweight resolver library and resolver daemon which new applications may choose to use to avoid the complexities of A6 chain following and bitstring labels.  See <A HREF="Bv9ARM.5.html#22731" CLASS="XRef">
The BIND&nbsp;9 Lightweight Resolver</A>
 for more information.</P>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=997809">
</A>
4.8.1	Address Lookups Using AAAA Records</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=1051979">
</A>
The AAAA record is a parallel to the IPv4 A record.  It specifies the entire address in a single record.  For example,</P>
<PRE>
<CODE><STRONG>
$ORIGIN example.com.
host	1h		IN	AAAA	3ffe:8050:201:1860:42::1
</STRONG></CODE></PRE>
<P CLASS="3LevelContinued">
<A NAME="pgfId=1052006">
</A>
While their use is deprecated, they are useful to support older IPv6 applications.  They should not be added where they are not absolutely necessary.</P>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1052015">
</A>
4.8.2	Address Lookups Using A6 Records</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=1052023">
</A>
The A6 record is more flexible than the AAAA record, and is therefore more complicated.  The A6 record can be used to form a chain of A6 records, each specifying part of the IPv6 address.  It can also be used to specify the entire record as well.  For example, this record supplies the same data as the AAAA record in the previous example:</P>

<PRE>
<CODE><STRONG>$ORIGIN example.com.
host	1h		IN	A6	0	3ffe:8050:201:1860:42::1</STRONG></CODE>
</PRE>

<DIV>

<H5 CLASS="4Level">
<A NAME="pgfId=1052021">
</A>
4.8.2.1	A6 Chains</H5>

<P CLASS="4LevelContinued">
<A NAME="pgfId=1052047">
</A>
A6 records are designed to allow network renumbering. This works when an A6 record only specifies the part of the address space the domain owner controls.  For example, a host may be at a company named &quot;company.&quot;  It has two ISPs which provide IPv6 address space for it.  These two ISPs fully specify the IPv6 prefix they supply.</P>
<P CLASS="4LevelContinued">
<A NAME="pgfId=1052048">
</A>
In the company's address space:</P>

<PRE>
<CODE><STRONG>$ORIGIN	example.com.
host	1h	IN	A6	64	0:0:0:0:42::1	company.example1.net.
host	1h	IN	A6	64	0:0:0:0:42::1	company.example2.net.</STRONG></CODE>
</PRE>

<P CLASS="4LevelContinued">
<A NAME="pgfId=1052050">
</A>
ISP1 will use:</P>
<PRE>
<CODE><STRONG>
$ORIGIN example1.net.
company		1h		IN		A6	0	3ffe:8050:201:1860::
</STRONG></CODE></PRE>
<P CLASS="4LevelContinued">
<A NAME="pgfId=1052052">
</A>
ISP2 will use:</P>
<PRE>
<CODE><STRONG>
$ORIGIN example2.net.
company		1h		IN		A6	0	1234:5678:90ab:fffa::
</STRONG></CODE></PRE>
<P CLASS="4LevelContinued">
<A NAME="pgfId=1052054">
</A>
When <EM CLASS="URL">
host.example.com</EM>
 is looked up, the resolver (in the resolver daemon or caching name server) will find two partial A6 records, and will use the additional name to find the remainder of the data.</P>
</DIV>
<DIV>

<H5 CLASS="4Level">
<A NAME="pgfId=1052010">
</A>
4.8.2.2	A6 Records for DNS Servers</H5>

<P CLASS="4LevelContinued">
<A NAME="pgfId=1052093">
</A>
When an A6 record specifies the address of a name server, it should use the full address rather than specifying a partial address.  For example:</P>

<PRE>
<CODE><STRONG>$ORIGIN example.com.
@		4h	IN	NS	ns0
		4h	IN	NS	ns1

ns0		4h	IN	A6	0		3ffe:8050:201:1860:42::1
ns1		4h	IN	A	192.168.42.1</STRONG></CODE>
</PRE>

<P CLASS="4LevelContinued">
<A NAME="pgfId=1052097">
</A>
It is recommended that IPv4-in-IPv6 mapped addresses not be used.  If a host has an IPv4 address, use an A record, not an A6, with <EM CLASS="grammar_literal">
::ffff:192.168.42.1</EM>
 as the address.</P>
</DIV>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1052088">
</A>
4.8.3	Address to Name Lookups Using Nibble Format</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=1052192">
</A>
While the use of nibble format to look up names is deprecated, it is supported for backwards compatiblity with existing IPv6 applications.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=1052193">
</A>
When looking up an address in nibble format, the address components are simply reversed, just as in IPv4, and <EM CLASS="grammar_literal">
ip6.int.</EM>
 is appended to the resulting name.  For example, the following would provide reverse name lookup for a host with address <EM CLASS="grammar_literal">
3ffe:8050:201:1860:42::1</EM>
.</P>


<PRE>
<CODE><STRONG>$ORIGIN 0.6.8.1.1.0.2.0.0.5.0.8.e.f.f.3.ip6.int.
1.0.0.0.0.0.0.0.0.0.0.0.2.4.0.0	4h										IN	PTR	host.example.com.
</STRONG></CODE></PRE>
</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1052007">
</A>
4.8.4	Address to Name Lookups Using Bitstring Format</H4>

<P CLASS="3LevelContinued">
<A NAME="pgfId=1052241">
</A>
Bitstring labels can start and end on any bit boundary, rather than on a multiple of 4 bits as in the nibble format. They also use <EM CLASS="URL">
ip6.arpa</EM>
 rather than <EM CLASS="URL">
ip6.int</EM>
.</P>
<P CLASS="3LevelContinued">
<A NAME="pgfId=1052242">
</A>
To replicate the previous example using bitstrings:</P>

<PRE>
<CODE><STRONG>$ORIGIN \[x3ffe805002011860/64].ip6.arpa.
\[x0042000000000001/64]											4h		IN		PTR		host.example.com.</STRONG></CODE>
</PRE>

</DIV>
<DIV>

<H4 CLASS="3Level">
<A NAME="pgfId=1052235">
</A>
4.8.5	Using DNAME for Delegation of IPv6 Reverse Addresses</H4>

In IPV6, the same host may have many addresses from many network providers.  Since the trailing portion of the address usually remains constant, DNAME can help reduce the number of zone files used for reverse mapping that need to be maintained.

For example, consider a host which has two providers (example.net and example2.net) and therefore two IPv6 addresses.  Since the host chooses its own 64 bit host address portion, the provider address is the only part that changes:

<PRE>
<CODE><STRONG>$ORIGIN example.com.
host		A6	64 ::1234:5678:1212:5675 cust1.example.net.
		A6	64 ::1234:5678:1212:5675 subnet5.example2.net.
</STRONG></CODE></PRE>
<PRE>
<CODE><STRONG>$ORIGIN example.net.
cust1		A6	48 0:0:0:dddd:: ipv6net.example.net.
ipv6net		A6	0  aa:bb:cccc::
</STRONG></CODE></PRE>
<PRE>
<CODE><STRONG>$ORIGIN example2.net.
subnet5		A6	48 0:0:0:1:: ipv6net2.example2.net.
ipv6net2	A6	0  6666:5555:4::</STRONG></CODE>
</PRE>

This sets up forward lookups.  To handle the reverse lookups, the provider example.net would have:

<PRE>
<CODE><STRONG>$ORIGIN \[x00aa00bbcccc/48].ip6.arpa.
\[xdddd/16]		DNAME		ipv6-rev.example.com.
</STRONG></CODE></PRE>
and example2.net would have:

<PRE>
<CODE><STRONG>$ORIGIN \[x666655550004/48].ip6.arpa.
\[x0001/16]		DNAME		ipv6-rev.example.com.
</STRONG></CODE></PRE>
example.com needs only one zone file to handle both of these reverse mappings:

<PRE>
<CODE><STRONG>$ORIGIN ipv6-rev.example.com.
\[x1234567812125675/64]		PTR		host.example.com.</STRONG></CODE>
</PRE>


</DIV>
</DIV>
<HR ALIGN="center">
<p>Return to <A href="Bv9ARM.html">BIND 9 Administrator Reference Manual</A> table of contents.</p>

</BODY>
</HTML>
